-- 데이터 정의어 (DDL, Data Definition Language)
-- : 객체 (object)의 생성, 변경, 삭제 언어
-- ※ 객체 (object) : 테이블, 뷰, 인덱스, 시퀀스 .....

-- 수행 내용이 바로 반영 (자동 COMMIT, ROLLBACK 불가)

-- 테이블 생성: CREATE TABLE 테이블명
CREATE TABLE STUDENT (
    STUID NUMBER(10),
    NAME VARCHAR2(10),
    GRADE NUMBER(3)
);

SELECT * FROM TAB;


-- 테이블 삭제: DROP TABLE 테이블명
DROP TABLE STUDENT;

-- 휴지통 내용물 확인
SELECT * FROM RECYCLEBIN;

-- 휴지통 영구히 삭제
PURGE RECYCLEBIN;

-- 휴지통에 있는 테이블 복구
FLASHBACK TABLE STUDENT TO BEFORE DROP;


-- 테이블 안에 열 변경: ALTER TABLE 테이블명
-- 1) 열 추가
DESC STUDENT;
ALTER TABLE STUDENT
ADD ADMISSIONDATE DATE;

-- 2) 열 이름 변경
ALTER TABLE STUDENT
RENAME COLUMN ADMISSIONDATE TO ADDATE;
DESC STUDENT;

-- 3) 열 데이터타입 변경
ALTER TABLE STUDENT
MODIFY ADDATE VARCHAR2(10);
DESC STUDENT;

-- 4) 열 삭제
ALTER TABLE STUDENT
DROP COLUMN ADDATE;
DESC STUDENT;

-- 테이블 변경
-- 1) 테이블 이름 변경
RENAME STUDENT TO GOOTT_STUDENT;
SELECT * FROM TAB;

-- 2) 테이블 내부 데이터 모두 삭제
TRUNCATE TABLE GOOTT_STUDENT; -- DDL (자동적 COMMIT, ROLLBACK 불가!)
SELECT * FROM GOOTT_STUDENT;

DELETE FROM GOOTT_STUDENT; -- DML (수동적 COMMIT) 

-- 3) 테이블 삭제
DROP TABLE GOOTT_STUDENT;
SELECT * FROM TAB;
SELECT * FROM RECYCLEBIN;
PURGE RECYCLEBIN;


-- 제약 조건 (Constraint)
-- : 테이블에 저장할 데이터에 대한 규칙
-- : 보통 DDL과 함께 사용

/*
1) NOT NULL: NULL 허용 X (데이터 중복 가능)
2) UNIQUE: 데이터 중복 불가 (NULL은 중복 데이터 제외)
3) PRIMARY KEY: 기본키 (1, 2 포함)
4) FOREIGN KEY: 외래키 (다른 테이블의 기본키로 설정된 열 참조하는 값, 
                                (*) 참조할 테이블이 먼저 생성되어야 함)
5) CHECK: 조건식에 만족하는 데이터만 입력 가능
6) DEFAULT: 열에 들어갈 데이터 기본값 설정할 수 있음 (제약 조건 아님)
*/

-- 테이블 생성
-- GAME_USER
-- ID: NUMBER(20), PRIMARY KEY
-- USERID: VARCHAR2(20), NOT NULL
-- USERPASS: VARCHAR2(20), NOT NULL, CHECK 8 ~ 16
-- NAME: VARCHAR2(10), NOT NULL

CREATE TABLE GAME_USER (
    ID NUMBER(20) PRIMARY KEY,
    USERID VARCHAR2(20) NOT NULL,
    USERPASS VARCHAR2(20) NOT NULL CHECK (LENGTH(USERPASS) BETWEEN 8 AND 16),
    NAME VARCHAR2(10) NOT NULL
);

DESC GAME_USER;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'GAME_USER';

-- 제약조건 이름 변경
ALTER TABLE GAME_USER
RENAME CONSTRAINT SYS_C007008 TO GAME_USER_USERID_NN;

ALTER TABLE GAME_USER
RENAME CONSTRAINT SYS_C007009 TO GAME_USER_USERPASS_NN;

ALTER TABLE GAME_USER
RENAME CONSTRAINT SYS_C007010 TO GAME_USER_NAME_NN;

ALTER TABLE GAME_USER
RENAME CONSTRAINT SYS_C007011 TO GAME_USER_USERPASS_CH;

ALTER TABLE GAME_USER
RENAME CONSTRAINT SYS_C007012 TO GAME_USER_PK;

-- PRIMARY KEY 설정된 열 이름 확인
SELECT COLUMN_NAME
FROM ALL_CONS_COLUMNS
WHERE CONSTRAINT_NAME = 
(SELECT CONSTRAINT_NAME FROM USER_CONSTRAINTS 
WHERE TABLE_NAME = 'GAME_USER' AND CONSTRAINT_TYPE = 'P');  

/*
C: CHECK, NOT NULL
U: UNIQUE
P: PRIMARY KEY
R: FOREIGN KEY
V: VIEW에서 WITH CHECK OPTION
O: VIEW에서 WITH READ ONLY
*/

-- Q1. 데이터 INSERT, ID나 PASS가 NULL이 들어오게 되는 경우 오류 확인
INSERT INTO GAME_USER VALUES(1, NULL, NULL, 'SALLY');

-- Q2. 데이터 INSERT, PASS의 자릿수가 8 ~ 16이 아닐 때 오류 확인
INSERT INTO GAME_USER VALUES(1, 'A', '1234567', 'SALLY');

-- 제약 조건 설정
DROP TABLE GAME_USER;
CREATE TABLE GAME_USER (
    ID NUMBER(20) CONSTRAINT GAME_USER_PK PRIMARY KEY,
    USERID VARCHAR2(20) CONSTRAINT GAME_USER_USERID_NN NOT NULL,
    USERPASS VARCHAR2(20) 
        CONSTRAINT GAME_USER_USERPASS_NN NOT NULL 
        CONSTRAINT GAME_USER_USERPASS_CH CHECK (LENGTH(USERPASS) BETWEEN 8 AND 16),
    NAME VARCHAR2(10) CONSTRAINT GAME_USER_NAME_NN NOT NULL
);

DROP TABLE GAME_USER;
CREATE TABLE GAME_USER (
    "ID" NUMBER(20),
    "USERID" VARCHAR2(20) CONSTRAINT GAME_USER_USERID_NN NOT NULL,
    "USERPASS" VARCHAR2(20) CONSTRAINT GAME_USER_USERPASS_NN NOT NULL,
    "NAME" VARCHAR2(10) CONSTRAINT GAME_USER_NAME_NN NOT NULL,
    "LEVEL" NUMBER(5) DEFAULT 0,
    
    -- PRIMARY KEY, FOREIGN KEY, UNIQUE, CHECK
    -- DEFAULT, NOT NULL은 아래로 뺄 수 없음
    CONSTRAINT GAME_USER_PK PRIMARY KEY (ID),
    CONSTRAINT GAME_USER_USERPASS_CH CHECK (LENGTH(USERPASS) BETWEEN 8 AND 16)
);

INSERT INTO GAME_USER (ID, USERID, USERPASS, NAME) VALUES (1, 'A', '12345678', 'SALLY');
SELECT * FROM GAME_USER;
COMMIT;

-- FOREIGN KEY 
-- FOREGIEN KEY (열 이름) REFERENCES 참조 테이블 (열 이름)
-- (*) 참조 테이블은 먼저 생성되어야 함

-- EX) 생성: DEPT_SIMPLE (A) --> EMP_SIMPLE (B)
--      삭제: EMP_SIMPLE (B) --> DEPT_SIMPLE (A)

SELECT * FROM EMP;
SELECT * FROM DEPT;

CREATE TABLE DEPT_SIMPLE (
    DEPTNO NUMBER(2) CONSTRAINT DEPT_SIMPLE_PK PRIMARY KEY,
    DNAME VARCHAR2(14),
    LOC VARCHAR2(13)
);

CREATE TABLE EMP_SIMPLE (
    EMPNO NUMBER(4), -- CONSTRAINT EMP_SIMPLE_PK PRIMARY KEY
    ENAME VARCHAR2(10),
    DEPTNO NUMBER(2),  -- CONSTRAINT EMP_SIMPLE_FK REFERENCES DEPT_SIMPLE(DEPTNO),
    CONSTRAINT EMP_SIMPLE_PK PRIMARY KEY(EMPNO),
    CONSTRAINT EMP_SIMPLE_FK FOREIGN KEY(DEPTNO) REFERENCES DEPT_SIMPLE(DEPTNO)
);

DROP TABLE EMP_SIMPLE;
DROP TABLE DEPT_SIMPLE;

-- (*) 만약에 FOREIGN KEY에 없는 데이터를 참조하려고 하면 오류 남
INSERT INTO DEPT_SIMPLE VALUES (10, 'DEVELOP', 'SEOUL');
COMMIT;
INSERT INTO EMP_SIMPLE VALUES (1111, 'SALLY', 20);
INSERT INTO EMP_SIMPLE VALUES (2222, 'GOOTT', 10);
COMMIT;

-- 10번 부서를 삭제
-- (*) 만약에 FOREIGN KEY를 참조하고 있는 데이터가 있을 때 FOREIGN KEY를 삭제하려고 하면 오류 남
DELETE FROM DEPT_SIMPLE WHERE DEPTNO = 10;

-- 해소 방법?
-- (1) FOREIGN KEY를 참조하고 있는 데이터를 NULL로 변경
UPDATE EMP_SIMPLE
SET DEPTNO = NULL
WHERE EMPNO = 2222;

-- (2) FOREIGN KEY를 삭제
DELETE FROM DEPT_SIMPLE WHERE DEPTNO = 10;
COMMIT; 

-- (****) FOREIGN KEY는 수정이 빈번하지 않은 열에 대해 지정

/*
ON DELETE CASCADE: FOREIGN KEY를 삭제하려고 하면 FOREIGN KEY를 참조하고 있는 데이터 같이 삭제
ON DELETE SET NULL: FOREIGN KEY를 삭제하려고 하면 FOREIGN KEY를 참조하고 있는 데이터를 NULL로 변경
*/
DROP TABLE EMP_SIMPLE;
DROP TABLE DEPT_SIMPLE;

CREATE TABLE DEPT_SIMPLE (
    DEPTNO NUMBER(2) CONSTRAINT DEPT_SIMPLE_PK PRIMARY KEY,
    DNAME VARCHAR2(14),
    LOC VARCHAR2(13)
);

CREATE TABLE EMP_SIMPLE (
    EMPNO NUMBER(4), -- CONSTRAINT EMP_SIMPLE_PK PRIMARY KEY
    ENAME VARCHAR2(10),
    DEPTNO NUMBER(2),  -- CONSTRAINT EMP_SIMPLE_FK REFERENCES DEPT_SIMPLE(DEPTNO),
    CONSTRAINT EMP_SIMPLE_PK PRIMARY KEY(EMPNO),
    CONSTRAINT EMP_SIMPLE_FK FOREIGN KEY(DEPTNO) REFERENCES DEPT_SIMPLE(DEPTNO) ON DELETE CASCADE
);

INSERT INTO DEPT_SIMPLE VALUES (10, 'DEVELOP', 'SEOUL');
INSERT INTO EMP_SIMPLE VALUES (2222, 'GOOTT', 10);
COMMIT;

-- 10번 부서를 삭제
DELETE FROM DEPT_SIMPLE WHERE DEPTNO = 10;
COMMIT;

SELECT * FROM EMP_SIMPLE;
SELECT * FROM DEPT_SIMPLE;

SELECT * FROM USER_CONSTRAINTS;
PURGE RECYCLEBIN;

-- 제약조건 활성화/비활성화
-- 비활성화 WHEN? 테스트 업무

ALTER TABLE EMP_SIMPLE
DISABLE CONSTRAINT EMP_SIMPLE_FK;

SELECT * FROM USER_CONSTRAINTS;
SELECT * FROM EMP_SIMPLE;
SELECT * FROM DEPT_SIMPLE;

-- EMP_SIMPLE_FK 제약조건이 비활성화되어서 DEPTNO로 존재하지 않는 30번 부서에 사원 삽입 가능
INSERT INTO EMP_SIMPLE VALUES (3333, 'GILDONG', 30);
COMMIT;

-- EMP_SIMPLE_FK 제약조건을 다시 활성화시키려면 제약조건에 맞게 데이터 변경
DELETE FROM EMP_SIMPLE WHERE EMPNO = 3333;
COMMIT;

ALTER TABLE EMP_SIMPLE
ENABLE CONSTRAINT EMP_SIMPLE_FK;




