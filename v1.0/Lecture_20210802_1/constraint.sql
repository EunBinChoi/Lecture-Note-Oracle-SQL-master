/* 제약조건 (constraint)
 * : 테이블에 저장할 데이터에 대한 규칙
 * : 데이터 정의어 (DDL)과 같이 사용
 * 
 * 1) NOT NULL: 지정한 열에 NULL 허용하지 않음
 * (데이터 중복은 허용 => user1: scott, user2: scott)
 * 2) UNIQUE: 지정한 열이 유일한 값 (중복 X)
 * (데이터에 NULL은 중복 제외)
 * 3) PRIMARY KEY (기본키): 유일한 값 + NULL을 허용하지 않음
 * (하나의 테이블에 하나만 지정할 수 있음)
 * 4) FOREIGN KEY (외래키): 다른 테이블의 열 참조하는 값만 입력 가능
 * 5) CHECK: 조건식에 만족하는 데이터만 입력 가능 
 * 6) DEFAULT: 열에 들어갈 데이터 기본값을 지정할 수 있음 (제약조건은 아님)
 * 
 * * 테이블이 생성될 때 제약조건을 같이 지정 (보통)
 * * 나중에 테이블 변경시에도 지정할 수는 있음
 * */

-- 테이블 생성 
-- EX) GAME_ID_PASS
-- GAME_ID VARCHAR(20) NOT NULL
-- GAME_PASS VARCHAR(20) NOT NULL
-- LASTDATE DATE

-- 1) NOT NULL
DROP TABLE GAME_ID_PASS;
CREATE TABLE GAME_ID_PASS(
	GAME_ID VARCHAR(20) NOT NULL,
	GAME_PASS VARCHAR(20) NOT NULL,
	LASTDATE DATE
);

SELECT * FROM GAME_ID_PASS;

-- ID, PASS, LASTDATE를 INSERT INTO
INSERT INTO GAME_ID_PASS
VALUES ('eunbin', '1234', SYSDATE);

-- GAME_ID, GAME_PASS에 데이터를 넣지 않음 (오류)
INSERT INTO GAME_ID_PASS(LASTDATE)
VALUES (SYSDATE);

-- GAME_PASS에 NULL을 넣을 수가 없음 (오류)
INSERT INTO GAME_ID_PASS
VALUES ('eunbin', NULL, SYSDATE);

SELECT * FROM GAME_ID_PASS;

-- GAME_PASS만 NULL으로 변경 (오류)
UPDATE GAME_ID_PASS
SET GAME_PASS = NULL
WHERE GAME_ID = 'eunbin';

-- 제약 조건 조회
SELECT * 
FROM USER_CONSTRAINTS 
WHERE TABLE_NAME = 'GAME_ID_PASS';
/* OWNER: 제약 조건 소유 계정
 * CONSTRAINT_NAME: 제약 조건 이름 (생략시 오라클 자동 생성)
 * CONSTRAINT_TYPE: 제약 조건 종류
 * C: CHECK, NOT NULL
 * U: UNIQUE
 * P: PRIMARY KEY
 * R: FOREIGN KEY
 * V: VIEW에서 WITH CHECK OPTION
 * O: VIEW에서 WITH READ ONLY
 * */


-- 제약 조건 이름 지정
-- >> 제약 조건 관리를 위해 이름을 지정해주는 것이 좋음
CREATE TABLE GAME_ID_PASS_CONS_NAME(
	GAME_ID VARCHAR(20) CONSTRAINT ID_NN NOT NULL,
	GAME_PASS VARCHAR(20) CONSTRAINT PASS_NN NOT NULL,
	LASTDATE DATE
);

SELECT * FROM USER_CONSTRAINTS;

-- 이미 생성한 테이블에 제약 조건 추가
/* 형식)
 * ALTER TABLE 테이블명
 * MODIFY (열이름 제약조건)
 */

-- 제약 조건 추가
ALTER TABLE GAME_ID_PASS_CONS_NAME
MODIFY (LASTDATE CONSTRAINT LD_NN NOT NULL);

-- 제약 조건 삭제
ALTER TABLE GAME_ID_PASS_CONS_NAME
DROP CONSTRAINT SYS_C007023;

SELECT * FROM USER_CONSTRAINTS;

-- 제약 조건 이름 변경 (기존에 동일한 제약조건 이름이 있으면 오류!)
ALTER TABLE GAME_ID_PASS
RENAME CONSTRAINT SYS_C007019 TO ID_NN2;

-- SYS_C007020, C007018의 이름 변경
ALTER TABLE GAME_ID_PASS
RENAME CONSTRAINT SYS_C007020 TO PASS_NN2;

-- 확인!
ALTER VIEW VW_EMP
RENAME CONSTRAINT SYS_C007018 TO VW_EMP_CHECK;

ALTER TABLE GAME_ID_PASS
DROP CONSTRAINT ID_NN2;

ALTER TABLE GAME_ID_PASS
DROP CONSTRAINT PASS_NN2;

SELECT * FROM USER_CONSTRAINTS;

-- 2) UNIQUE
-- : 데이터의 중복을 허용 X
-- : NULL값은 중복에 포함되지 않음 (NULL 여러 개 가능)

-- STUDENT 테이블
-- ID: UNIQUE => ID_UQ
-- NAME: NOT NULL => NAME_NN
-- PHONE
SELECT * FROM TAB;

DROP TABLE STUDENT;
CREATE TABLE STUDENT(
	ID VARCHAR(20) CONSTRAINT ID_UQ UNIQUE,
	NAME VARCHAR(20) CONSTRAINT NAME_NN NOT NULL,
	PHONE VARCHAR(20)
);


SELECT * 
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'STUDENT';

-- 데이터 삽입 2명 (ID가 같은)
INSERT INTO STUDENT
VALUES ('2021001', '홍길동', '010-1234-5678');
INSERT INTO STUDENT -- ID UNIQUE 제약조건 위배
VALUES ('2021001', '홍길순', '010-1234-1234');

-- 데이터 삽입 2명 (ID가 NULL) -- UNIQUE 제약조건 위배 X
INSERT INTO STUDENT
VALUES (NULL, '홍길동', '010-1234-5678');
INSERT INTO STUDENT 
VALUES (NULL, '홍길순', '010-1234-1234');

SELECT * FROM STUDENT;

SELECT * FROM USER_CONSTRAINTS;

-- 제약 조건 삭제
ALTER TABLE STUDENT
DROP CONSTRAINT ID_UQ;


-- 제약 조건 추가 (ID_UQ)
-- 제약 조건 추가 불가! (이미 ID가 UNIQUE 하지 않음)
ALTER TABLE STUDENT
MODIFY (ID CONSTRAINT ID_UQ UNIQUE);

DELETE FROM STUDENT
WHERE ID = '2021001' AND NAME = '홍길순';

SELECT * FROM STUDENT;
SELECT * FROM USER_CONSTRAINTS;

-- 제약 조건 이름 변경 (ID_UQ -> ID_UNIQUE)
ALTER TABLE STUDENT
RENAME CONSTRAINT ID_UQ TO ID_UNIQUE;


-- 3) PRIMARY KEY (기본키)
-- : UNIQUE + NOT NULL
-- : 기본키가 다른 데이터를 대표할 수 있는 열로 지정
-- : 테이블에서 오직 한 개만 존재
-- : 해당 열에는 자동으로 인덱스 만들어짐 (보통 기본키가 SELECT문에 자주 사용) 

-- Q1. PERSON이라는 TABLE을 생성
-- ID NUMBER(2)
-- NAME VARCHAR(20)
-- GENDER VARCHAR(5)
-- REGISTRATION VARCHAR(15)

-- A. PRIMARY KEY(기본키)가 될 수 있는 열 (+ 제약 조건 이름 지정)
-- B. NAME NOT NULL (+ 제약 조건 이름 지정)

CREATE TABLE PERSON( -- 열 레벨/인 라인 제약 조건 정의
	ID NUMBER(2) CONSTRAINT PID_PK PRIMARY KEY,
	NAME VARCHAR(20) CONSTRAINT PNAME_NN NOT NULL,
	GENDER VARCHAR(5),
	REGISTRATION VARCHAR(15)
);

CREATE TABLE PERSON( -- 테이블 레벨/아웃 라인 제약 조건 정의
	ID NUMBER(2),
	NAME VARCHAR(20),
	GENDER VARCHAR(5),
	REGISTRATION VARCHAR(15),
	CONSTRAINT PID_PK PRIMARY KEY (ID),
--	CONSTRAINT PNAME_NN NOT NULL (NAME)
	-- 테이블 레벨 제약 조건 정의는 NOT NULL 지정할 수 없음
	-- PRIMARY KEY, UNIQUE, FOREIGN KEY ....
);

SELECT * FROM USER_CONSTRAINTS;

-- PRIMARY KEY (기본키)는 데이터를 식별하는 유일한 값 
-- (SELECT 문에 많이 사용 => INDEX로 지정)
-- 인덱스 이름은 제약 조건 이름과 동일해짐
SELECT * FROM USER_INDEXES;


-- PERSON 테이블에 총 5명을 삽입
-- 1) PERSON 테이블에 ID는 SEQUENCE를 통해 생성 (SEQ_PERSON)
-- START WITH: 1
-- MINVALUE: 1
-- MAXVALUE: 5
-- INCREMENT BY: 1
-- CYCLE
-- NOCACHE

CREATE SEQUENCE SEQ_PERSON
INCREMENT BY 1
START WITH 1
MINVALUE 1
MAXVALUE 5
CYCLE
NOCACHE;

SELECT * FROM USER_SEQUENCES;

-- 2) SEQ_PERSON을 통해 데이터 삽입
INSERT INTO PERSON (ID, NAME)
VALUES (SEQ_PERSON.NEXTVAL, '홍길동');
-- 총 6번을 실행하면 UNIQUE 조건에 만족하지 않음

SELECT * FROM PERSON;

INSERT INTO PERSON (ID, NAME)
VALUES (NULL, '홍길동');
-- NOT NULL 조건에 만족하지 않음

-- ALTER, MODIFY, RENAME, DROP문 작성할 수 있음!

-- 4) FOREIGN KEY (외래키, 외부키)
-- : 두 테이블의 관계 정의하는 제약 조건
-- ex) EMP, DEPT 
-- (EMP 테이블에서 DEPTNO는 외래키, DEPT 테이블에서 DEPTNO는 기본키)

SELECT * FROM USER_CONSTRAINTS;
SELECT * FROM EMP;
SELECT * FROM DEPT;

INSERT INTO EMP(EMPNO, ENAME, JOB, DEPTNO)
VALUES (5000, '이클립', 'DEVELOPER', 50);
-- 외래키가 참조하는 DEPT.DEPTNO에 50이 없기 때문에 오류

INSERT INTO EMP(EMPNO, ENAME, JOB, DEPTNO)
VALUES (5000, '이클립', 'DEVELOPER', NULL);
-- 외래키 지정: 참조하는 테이블의 기본키이거나 
-- NULL인 값 ('참조할 데이터가 없다!') 지정 가능!
-- 외래키가 NULL인 경우 JOIN을 하면 결과 테이블?
-- : 외래키가 NULL인 행 제외

SELECT *
FROM EMP JOIN DEPT ON (EMP.DEPTNO = DEPT.DEPTNO);

SELECT * FROM EMP;


-- FOREGIN KEY 지정
/* CREATE TABLE 테이블명(
 * 	.... (다른 열 정의),
 * 	열 자료형 CONSTRAINT [제약조건 이름 (선택)] REFERENCES 참조 테이블 (열)
 * );
 * 
 * CREATE TABLE 테이블명(
 * 	.... (다른 열 정의),
 * 	열 자료형,
 *  CONSTRAINT [제약조건 이름 (선택)] FOREIGN KEY (열 이름)
 *  REFERENCES 참조 테이블 (열)
 * );
 * 
 * */


-- DEPT_FK 테이블 생성
CREATE TABLE DEPT_FK(
	DEPTNO NUMBER(2) CONSTRAINT DEPT_FK_PK PRIMARY KEY,
	DNAME VARCHAR(20),
	LOC VARCHAR(20)
);

-- EMP_FK 테이블 생성 (DEPT_FK의 DEPTNO를 참조)
-- 기본키: EMPNO
-- 외래키: DEPTNO
CREATE TABLE EMP_FK(
	EMPNO NUMBER(4) CONSTRAINT EMP_FK_PK PRIMARY KEY,
	ENAME VARCHAR(20),
	JOB VARCHAR(20),
	MGR NUMBER(4),
	HIREDATE DATE,
	SAL NUMBER(7, 2),
	COMM NUMBER(7, 2),
	DEPTNO NUMBER(2) CONSTRAINT EMP_FK_FK REFERENCES DEPT_FK (DEPTNO)
);

CREATE TABLE EMP_FK(
	EMPNO NUMBER(4),
	ENAME VARCHAR(20),
	JOB VARCHAR(20),
	MGR NUMBER(4),
	HIREDATE DATE,
	SAL NUMBER(7, 2),
	COMM NUMBER(7, 2),
	DEPTNO NUMBER(2),
	CONSTRAINT EMP_FK_PK PRIMARY KEY (EMPNO),
	CONSTRAINT EMP_FK_FK FOREIGN KEY (DEPTNO) 
	REFERENCES DEPT_FK (DEPTNO)
);

INSERT INTO EMP_FK (EMPNO, ENAME, DEPTNO)
VALUES (1000, '홍길동', 10);
-- 외래키가 참조할 DEPTNO 생성되지 않은 채로 데이터 삽입이 불가능

INSERT INTO DEPT_FK (DEPTNO, DNAME, LOC)
VALUES (10, 'ACCOUTING', 'SEOUL');
-- 먼저 DEPTNO를 생성한 다음에 (1000, '홍길동', 10) 데이터 삽입 가능

SELECT * FROM EMP_FK;
SELECT * FROM DEPT_FK;

DELETE FROM DEPT_FK
WHERE DEPTNO = 10;
-- 오류 발생!
-- DEPTNO 10번을 참조하고 있는 레코드가 존재 ('홍길동')

/* 1. EMP 테이블의 '홍길동' 삭제하고 DEPT 테이블에 10번을 삭제
 * 2. EMP 테이블의 '홍길동'의 DEPTNO를 NULL 수정
 * 3. EMP 테이블의 FOREIGN KEY 제약조건 삭제
 * 
 * * FOREIGN KEY는 수정이 빈번하지 않은 열을 참조하는 게 좋음!
 * */

/* ON DELETE CASCADE: DEPT 테이블에 10번이 삭제될 경우에
 * 이를 참조하는 데이터를 함께 삭제
 * 
 * ON DELETE SET NULL: DEPT 테이블에 10번이 삭제될 경우에
 * 이를 참조하는 데이터를 NULL로 설정
 * */

DROP TABLE EMP_FK;
CREATE TABLE EMP_FK(
	EMPNO NUMBER(4) CONSTRAINT EMP_FK_PK PRIMARY KEY,
	ENAME VARCHAR(20),
	JOB VARCHAR(20),
	MGR NUMBER(4),
	HIREDATE DATE,
	SAL NUMBER(7, 2),
	COMM NUMBER(7, 2),
	DEPTNO NUMBER(2) 
	CONSTRAINT EMP_FK_FK 
	REFERENCES DEPT_FK (DEPTNO) ON DELETE CASCADE
);

DROP TABLE EMP_FK;
CREATE TABLE EMP_FK(
	EMPNO NUMBER(4),
	ENAME VARCHAR(20),
	JOB VARCHAR(20),
	MGR NUMBER(4),
	HIREDATE DATE,
	SAL NUMBER(7, 2),
	COMM NUMBER(7, 2),
	DEPTNO NUMBER(2),
	CONSTRAINT EMP_FK_PK PRIMARY KEY (EMPNO),
	CONSTRAINT EMP_FK_FK FOREIGN KEY (DEPTNO) 
	REFERENCES DEPT_FK (DEPTNO) ON DELETE SET NULL
);

-- Q1. EMP_FK, DEPT_FK를 생성
-- 1) ON DELETE SET NULL
INSERT INTO DEPT_FK (DEPTNO, DNAME, LOC)
VALUES (10, 'ACCOUNTING', 'SEOUL');
INSERT INTO EMP_FK (EMPNO, ENAME, DEPTNO)
VALUES (1000, '홍길동', 10);

SELECT * FROM EMP_FK;
SELECT * FROM DEPT_FK;

DELETE FROM DEPT_FK
WHERE DEPTNO = 10;

-- NULL으로 수정 (ON DELETE SET NULL 방식 이용)
SELECT * FROM EMP_FK;
SELECT * FROM DEPT_FK;

-- 2) ON DELETE CASCADE
INSERT INTO DEPT_FK (DEPTNO, DNAME, LOC)
VALUES (10, 'ACCOUNTING', 'SEOUL');
INSERT INTO EMP_FK (EMPNO, ENAME, DEPTNO)
VALUES (2000, '홍길동', 10);

SELECT * FROM EMP_FK;
SELECT * FROM DEPT_FK;


DELETE FROM DEPT_FK
WHERE DEPTNO = 10;

-- 데이터가 다 사라짐 (ON DELETE CASCADE 방식 이용)
SELECT * FROM EMP_FK;
SELECT * FROM DEPT_FK;


-- 5) CHECK
-- : 데이터에 조건을 지정 (값 범위, 패턴 정의)
-- EX) 나이: 1 ~ 99, 시: 0 ~ 23, 분: 0 ~ 59, 초: 0 ~ 59

DROP TABLE GAME_ID_PASS;
CREATE TABLE GAME_ID_PASS(
	LOGIN_ID VARCHAR(20) CONSTRAINT LOGIN_ID_PK PRIMARY KEY,
	LOGIN_PWD VARCHAR(20),
	PHONE VARCHAR(20) CONSTRAINT PHONE_CK CHECK (LENGTH(PHONE) > 11)
	-- 010-123-3456
);

DROP TABLE GAME_ID_PASS;
CREATE TABLE GAME_ID_PASS(
	LOGIN_ID VARCHAR(20),
	LOGIN_PWD VARCHAR(20),
	PHONE VARCHAR(20),
	CONSTRAINT LOGIN_ID_PK PRIMARY KEY (LOGIN_ID),
	CONSTRAINT PHONE_CK CHECK (LENGTH(PHONE) > 11)
);

SELECT * FROM GAME_ID_PASS;
SELECT * 
FROM USER_CONSTRAINTS 
WHERE TABLE_NAME = 'GAME_ID_PASS';


INSERT INTO GAME_ID_PASS (LOGIN_ID)
VALUES ('ID_3');

-- 데이터 2명 삽입
INSERT INTO GAME_ID_PASS 
VALUES ('ID_1', '1234', '010-11-1111');
-- PHONE의 제약조건에 위배

INSERT INTO GAME_ID_PASS 
VALUES ('ID_2', '1234', '010-111-1111');

SELECT * FROM GAME_ID_PASS;

INSERT INTO GAME_ID_PASS (PHONE)
VALUES ('010-111-1111');
-- ID는 기본키 지정 (UNIQUE + NOT NULL)
-- 기본키로 지정된 ID가 NULL이면 제약조건 위배

-- 6) DEFAULT (기본값)
-- : 기본값 지정
-- : 특정 열에 아무 값도 들어오지 않을 경우에 기본값으로 지정
-- : 제약조건 아님 (USER_CONSTRAINTS에 추가되지 않음)

-- 테이블 이름
-- : 유투브 프리미엄 멤버 (YT_PR_MEMBER)
-- 열 구성
-- 1) ID: VARCHAR(20) (PRIMARY KEY) 
-- (1aaaa(x), aaa1(o) CHECK)
-- (111aaaa(x), aaa111(o) CHECK)
-- 사전 순서

-- 2) PW: VARCHAR(20) (CHECK로 7자리를 넘겨야 함)
-- 3) NAME: VARCHAR(10)
-- 4) BIRTHDAY: DATE
-- 5) REGDATE: DATE (데이터 삽입, SYSDATE)
-- 6) ISPAID: NUMBER(1) (1 - TRUE, 0 - FALSE) (DEFAULT 0)
DROP TABLE YT_PR_MEMBER;
CREATE TABLE YT_PR_MEMBER(
	ID VARCHAR(20),
	PW VARCHAR(20),
	NAME VARCHAR(10),
	BIRTHDAY DATE,
	REGDATE DATE DEFAULT SYSDATE,
	ISPAID NUMBER(1) DEFAULT 0,
	CONSTRAINT YT_ID_PK PRIMARY KEY(ID),
	CONSTRAINT YT_PW_CK CHECK (LENGTH(PW) > 7),
	CONSTRAINT YT_ID_CK CHECK 
	(UPPER(ID) BETWEEN 'A' AND 'Z')
);
-- 숫자 + 영어 사전
-- 111a -> '1'
-- a111 -> 'a'

SELECT *
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'YT_PR_MEMBER';

-- NULL => 제약조건을 확인하지 않음 (PW가 입력이 안되어있음 (NULL))
INSERT INTO YT_PR_MEMBER(ID, NAME)
VALUES ('gildong', '홍길동');

SELECT * FROM YT_PR_MEMBER;

-- 실행 X (아이디에 첫문자가 숫자라서)
INSERT INTO YT_PR_MEMBER(ID, NAME)
VALUES ('1gildong', '홍길동');

-- 실행 X (패스워드가 7글자가 넘지 않음)
INSERT INTO YT_PR_MEMBER(ID, NAME, PW)
VALUES ('gilsun', '홍길순', '1234');

-- ID가 기본키라서 NULL값을 가질 수가 없음
INSERT INTO YT_PR_MEMBER(NAME)
VALUES ('홍홍');

INSERT INTO YT_PR_MEMBER
VALUES ('eunbin', '12345678', '박박', 
TO_DATE('1990/11/30', 'YYYY/MM/DD'), SYSDATE, NULL);
-- 디폴트 값이 있던 ISPAID 열에 
-- NULL을 명시적으로 넣게 되면 NULL 설정

INSERT INTO YT_PR_MEMBER (ID, PW, NAME)
VALUES ('echoi', '12345678', '최최');
-- 디폴트 값이 있던 ISPAID 열에 
-- 아무 값도 넣지 않으면 디폴트 값으로 설정

SELECT * FROM YT_PR_MEMBER;
SELECT * 
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'YT_PR_MEMBER';

/* 제약조건 활성화/비활성화
 * : 활성화 - 제약조건 확인 (ENABLE)
 * : 비활성화 - 제약조건 확인 X (DISABLE)
 * 비활성화 언제 ?
 * 1) 테스트 업무시에 제약조건을 잠깐 꺼둠
 * */

-- 비활성화
ALTER TABLE YT_PR_MEMBER
DISABLE CONSTRAINT YT_ID_CK;

SELECT * 
FROM USER_CONSTRAINTS
WHERE CONSTRAINT_NAME = 'YT_ID_CK';

-- 활성화
ALTER TABLE YT_PR_MEMBER
ENABLE CONSTRAINT YT_ID_CK;


/* 제약조건  | 제약조건 타입
 * NOT NULL (C)
 * UNIQUE  (U) - NULL값 허용
 * PRIMARY KEY (P) 
 * FOREIGN KEY (R) - NULL값 허용
 * - ON DELETE CASCADE: 
 * '내가 참조하고 있는 데이터가 삭제되면 나도 삭제'
 * - ON DELETE SET NULL: 
 * '내가 참조하고 있는 데이터가 삭제되면 나는 NULL 설정'
 * CHECK (C) - NULL값 CHECK (조건식)을 무시하고 NULL로 삽입
 * 
 * -- DISABLE, ENABLE
 * 
 * DEFAULT - NULL 명시적으로 삽입하면 NULL값 허용
 *         - NULL 명시적으로 삽입하지 않으면 기본값이 삽입됨 
 * */



